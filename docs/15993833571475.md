# KMP 算法
kmp 全名 <b>Knuth-Morris-Pratt 算法</b>, 是用于求解模式串是否在源串中匹配的算法。相比于朴素的BF算法二重循环 $O(m \times n)$ 的复杂度，它不需要回溯主串，使得算法复杂度降低到了线性的 $O(m + n)$ 。
## 一个迷幻的问题：为什么不需要回溯原始串了？
**注：
以下所指
$T$ 为主串, 
$P$ 为模式串，
$T_{i..j}$ 指主串的第 $i$ 个元素到第 $j$ 个元素形成的子串**

BF 算法之所以慢，是慢在它的循环操作上，每一次失配都会使得主串回溯。而KMP算法的失配却不需要这么干了。如何理解KMP算法中的这个优化?
1. 应该这么理解。与其说不需要回溯主串是KMP带来的优化，不如说KMP的目标是干掉回溯主串这个操作。正是因为想要保证主串不再回溯，KMP才设计了next数组（fail数组）
2. 实际上，主串不用回溯是可以证明的，假设我们在发生失配前已经匹配了$j$个字符。意味着模式串$P_1...j$ 和主串 $T_{l+1...l+j}$ 是匹配的。如果我们回溯到当前模式串起点对应的主串位置的下一位。也就是 $T_{l+2}$ 开始重新匹配。考虑如下情况
    1. 存在 $T_{l+2...l+j}$ 和 $P_{l...j-1}$ 匹配，则下一位匹配又将遇到 $T_{l+j+1}$ 和 $P_j$, 主串回到了回溯前的位置。
    2. 如果不存在这样的匹配，那么按照BF算法，模式串首位前移，主串指针也前移到$T_{l+3}$，此时要判断的就是$T_{l+3...l+j}$ 和 $P_{l...j-2}$ 是否相等。其计算方法一样的
    3. 那么最终要么是找到这样的匹配，使得下一步还是进行到$T_{l+j+1}$，要么是一直都没找到，直到再次回到当前点。
3. 那么，既然可以干掉回溯，为什么BF算法却不行？问题出在模式串的匹配策略上，BF算法的失配，会让模式串直接退回第一个字符。而实际上，虽然前面描述的回溯判断会让主串$T$ 回溯操作最后回到$T_{l+j+1}$, 但和它进行一一比对的模式串已经不是$P_j$而是$P_{j-1}$或者$p_{j-2}...$了。而这些匹配实际是有可能成功的，漏掉这些计算肯定是不正确的。
4. 因此，KMP的关键在于，保持主串不回溯，只通过修改模式串的匹配检查来避免“漏掉”特定的计算。说的再详细一点，就是检查是否存在 $x < j$, 使得 $P_{1...j-x} = T_{l+j+1-x...l+j+1}$, 且这个$x$ 应该越大越好。如果不存在这个x，说明不存在漏掉的计算。主串可以放心的后移了。模式串也可以从最初字符开始。如果存在这个字符串，则继续比较当前主串位置和$P_{j-x+1}$, 相当于快速推进了逐项比对流程。

## So, KMP到底怎么算？
### 核心思路: 双指针 + $fail$ 数组
双指针自然是一个 $match$ 指针指向模式串 $P$ (初始状态是指向-1)，一个i指针指向源串 $T$, 如果 $P_{match+1}$ 与 $T_i$ 匹配，就将模式串，源串指针后移, 即 $match + 1, i+1$。若不匹配，先尝试移动模式串指针，查看之前有没有重复模式，这样直接从前一个重复模式处重移动。若已经到达 $match= -1$ 。就移动 $i$ 来寻找下一个匹配模式串首字母的位置。
$kmp$ 算法会预先处理模式串，求出一个 $fail$ 数组

### 一个fail 数组实例
<table>
    <tr>
        <th></th>
        <th>a</th>
        <th>a</th>
        <th>b</th>
        <th>a</th>
        <th>b</th>
        <th>a</th>
        <th>a</th>
        <th>b</th>
    </tr>
    <tr>
        <td>$fail$</td>
        <td>-1</td>
        <td>0</td>
        <td>-1</td>
        <td>0</td>
        <td>-1</td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
    </tr>
</table>
    


### 基本解法
对于字符串 $S = S_0S_1...S_{n-1}$, 如果 $j$ 是满足 $S_{0...j}$ = $S_{i-j...i}$ 的最大值。则 $fail_i = j$ , 若不存在这样的 $j$, 则 $fail_i =0$

证明可以直接跳转到$fail[match]$的过程如下
    已知 $$P_{0...fail[match]} = P_{match-fail[match]…match} $$
    又有 $$P_{0...match} = T_{i-match…i} => P_{match-fail[match]...match} = T_{i-fail[match]…i} $$
    可得 $$P_{0...fail[match]} = T_{i-fail[match]…i}$$
从而得证

说白了，就是检查模式串中是否有中间部分和开头有重复。如果有，如果在当前位置遭遇匹配失败，则可以将模式串的指针
    直接跳转到fail数组设定的位置。重新尝试匹配，而不用又从模式串的头头开始
    
