# Levenshtein Distance 莱文斯坦距离算法
莱文斯坦距离，又称Levenshtein距离，是编辑距离的一种。**指两个字串之间，由一个转成另一个所需的最少编辑操作次数。**如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。


### 应用
通常作为计算两个字符串相似度的算法。
#### 计算相似度公式
**1-它们的距离/两个字符串长度的最大值。**

- 如果`str1="ivan"`，`str2="ivan"`，那么经过计算后等于 0。没有经过转换。相似度
$$1 - \frac{0}{Math.Max(str1.length, str2.length)} = 1$$
- 如果`str1="ivan1"`，`str2="ivan2"`，那么经过计算后等于1。str1的"1"转换"2"，转换了一个字符，所以距离是1，相似度
$$1-\frac{1}{Math.Max(str1.length,str2.length)}=0.8$$

#### 算法
1. str1或str2的长度为0返回另一个字符串的长度。 
2. 初始化 $(n+1)*(m+1)$ 的矩阵d，并让第一行和列的值从0开始增长。
3. 扫描 $(n*m)$ 矩阵范围内的两个字符串，
    1. 如果：`str1[i] == str2[j]`，记录一个temp为0。否则temp记为1。
    2. 将矩阵`d[i,j]`赋为`d[i-1,j]+1` 、`d[i,j-1]+1`、`d[i-1,j-1] + temp` 三者的最小值。
4. 扫描完后，返回矩阵的最后一个值`d[n][m]`即是它们的距离。

**ps：其实扫描的过程就是个动态规划的过程，这也是个动态规划思想的典型应用**

#### 实例
假设有两个字符串 *hey* 和 *hel*，
求其levenshtein距离的计算过程如下:
##### 步骤1
字符串长度为$3$, 因此初始化$5 * 5$的表格以及$4 * 4$的计数矩阵。第一行第一列均自然增长。这一步可以理解为，随着字符串内容的变化，和空字符串相比，其距离逐渐增加。例如字符串$h$, $he$,$hey$和空字符串相比，其距离为1,2,3

|  |  | h | e | y  |
| --- | --- | --- | --- | --- |
|   | 0 | 1 | 2 | 3 |
| h  | 1 |  |  |  |
| e  | 2 |  |  |  |
| l | 3 |  |  |  |

##### 步骤2
开始计算第二列的各个元素值，实际上如矩阵图所示，就等于在计算字符$h$和$h$, $he$, $hel$的距离。我们通过目测可以看出，距离依次为0，1，2，但为了付诸算法实现。实际的计算方法利用了动态规划:
   
1. 设置一个变量temp，标志当前元素变化检查当前元素i，j是否相等, 若相等设置temp = 0，否则为1
2. 获得  $d[i-1, j]$ , 即回溯获得当前 $x$ 方向字符串**新增一个字符前**和 $y$ 方向当前字符串的编辑距离。将此距离 $+1$ 即为当前两字符串的**候选编辑距离A.**
       - 例如对于 $h$ 和 $h$，就是去获得空字符串和 $h$ 的距离，即 $1$。
       - 因为在x方向从空字符串增长到 $h$ 需要增加1点编辑距离。因此当前的候选编辑距离为 $1 + 1 = 2$
       
1. 获得 $d[i, j-1]$，即回溯获得当前 $y$ 方向字符串**新增一个字符前**和 $y$ 方向当前字符串的编辑距离。将此距离 $+1$ 即为当前两字符串的**候选编辑距离B.**
       - 例如对于 $h$ 和 $h$，因为可以理解 $h$ 是通过 $y$ 方向的空字符串 新增一个 $h$ 获得的，所以去获得空字符串和 $h$ 的距离，即 $1$。
       - 因为在y方向从空字符串增长到 $h$ 需要增加1点编辑距离。因此当前的候选编辑距离为 $1 + 1 = 2$
2. 获得 $d[i-1, j-1]$，也就是i，j字符各退一个元素，对应理解为当前元素发生直接变化的情况。将此距离$+temp$ 即为当前两个字符串的**候选编辑距离C**
       - 例如对于 $h$ 和 $h$，我们可以理解为他是两个空字符串下一个位置上的元素发生了变化比较的。
       - 若变化的结果相同，说明实际上不用变，temp为$0$, 如果变化的结果不同，说明需要耗费一点编辑距离，temp为$1$。
       - 由于 $h$ 和 $h$ 相同，说明不需要耗费编辑距离，$d[i][j] = 0$, 因此**候选距离C**为$0 + temp = 0 + 0 = 0$
3. 比较三者，将最小编辑距离设置为当前d[i][j]的值, 也就是0
4. 其他字符依次按照算法计算即可。
   
|  |  | h | e | y  |
| --- | --- | --- | --- | --- |
|   | 0 | 1 | 2 | 3 |
| h  | 1 | 0 |  |  |
| e  | 2 | 1 |  |  |
| l | 3 | 2 |  |  |

##### 步骤3
计算到矩阵被填满，最后一个被填满的数 $d[m][n]$ 即为当前两个字符串的编辑距离。

|  |  | h | e | y  |
| --- | --- | --- | --- | --- |
|   | 0 | 1 | 2 | 3 |
| h  | 1 | 0 | 1 | 2 |
| e  | 2 | 1 | 0 | 1 |
| l | 3 | 2 | 1 | *1* |

#### 代码实现
```ts
function levenshteinDistance(a, b) {
  if (a.length === 0) {
    return b.length;
  }
  if (b.length === 0) {
    return a.length;
  }
  let matrix = [] as any[];
  // increment along the first column of each row
  let i;
  for (i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }
  // increment each column in the first row
  let j;
  for (j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  // Fill in the rest of the matrix
  for (i = 1; i <= b.length; i++) {
    for (j = 1; j <= a.length; j++) {
      // 在此情况下相当于temp = 0
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1, // substitution
          Math.min(
            matrix[i][j - 1] + 1, // insertion
            matrix[i - 1][j] + 1
          )
        ); // deletion
      }
    }
  }
  return matrix[b.length][a.length];
}
```