# Linux 命令踩坑
## 复制
递归的复制
```bash
cp -r source target 
```
在linux中通配符复制 
```bash
cp -u *.后缀名 target 
```
要想得到详细信息，并且确认是否覆盖重写文件，可以加 -vi 参数
如果想要忽略已存在的文件，可以使用
```bash
 -u (update的意思)
```
## 移动或改名
对文件/夹改名，实际上是使用 
```bash
mv file1 file2
```
查询命令位置/作用
想要找到某个可执行命令的位置，使用类似, 这个命令对内建命令和别名无效
```bash
which node 
# 结果为 /usr/bin/node
```
想要知道某个命令的作用
```bash
whatis some命令
```
## 重定向
如果我们需要清空一个文件内容（或者创建一个 新的空文件），可以使用这样的技巧：
通过将不存在的命令重定向到目标文件，会清空该文件
```bash
> target.txt
```
想要重定向标准错误, 需要制定标准错误的文件描述符， 即`2`
```bash
ls -l /bin/usr 2> target.txt
```
想要同时重定向
```bash
ls -l /bin/usr &> ls-output.txt
```
不想输出错误，想默默的处理掉，利用“位存储桶", 即`/dev/null` 这个特殊文件
```bash
ls -l /bin/usr 2> /dev/null
```
又想读取标准输入到文件又想复制到标准输出
使用tee 命令，这个类似于函数式编程里tap那样的管道，只展示，但不影响原始数据流动
```bash
ls /usr/bin | tee ls.txt | grep zip
```
## Cat 一个最简单的文本编辑器
使用 
```bash
cat > target.txt
```
此时会等待用户输入，当要退出时，按住ctrl + D 表示EOF，标准输入的数据就进入了target.txt
## 过滤器
- sort 用于排序
- uniq 用于去重
两者结合可以这么用 

```bash
ls /bin /usr/bin | sort | uniq | less
```

## 文本搜索 grep
>global search regular expression(RE) and print out the line
>全面搜索正则表达式并把行打印出来

grep 最好不要直接使用，和ls， sort， uniq这些结合，减少搜索范围
```bash
ls /bin /usr/bin | sort | uniq | grep zip
```
这样可以获得排序后的zip相关的独立文件名
## 查看文件的头尾

```bash
head/tail -n 10 test.txt # 查看文件的头/尾十行
tail -f # 实时观察文件，一有变动就展示
```
## ECHO
查看算术表达式
```bash
echo $((1+1))
```
花括号展开
```bash
echo Front-{A,B,C}-Back -> Front-A-Back Front-B-Back Front-C-Back
echo {Z..A} -> Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
echo a{A{1,2},B{3,4}}b -> aA1b aA2b aB3b aB4b
```
## 查看系统可用的变量
```bash
printenv | less
变量展开为 $(echo foo) 的形式
```
使用“”双引号来保存echo引用的值，这样其中的空格，花括号展开不会被解析
使用‘’单引号来保存echo引用的值，其中的表达式，变量都不会被解析

## 软连接和硬连接的不同
简言之，就是**软连接是一个文件**，而**硬连接是一个别名**。文件名就是由硬链接创建的
每一个独立的文件都有自己的inode(索引节点号), 软连接通过自己的inode去连接文件的dataBlock，而硬连接只是对inode做了另一个引用。存在引用计数。
硬连接无法对目录进行，无法跨越文件系统(跨硬盘), 删除不影响其他的硬连接，只能对已存在的文件进行创建。软连接所指向的数据如果被删除，该连接会成为死连接。但是如果对应的路径文件被重新创建。连接又会恢复为正常的软连接。
实际上，每个文件夹都有两个隐藏的目录（. 当前目录 .. 父目录）这两个目录实际上是两个硬链接（因为这两个的存在，系统不允许对任何目录创建硬连接，否则会出现目录环）
对于软连接，如果创建的软连接不是在当前目录下，比如在子目录下，那么被创建软连接的原文件一定要是相对于软连接位置来定的。同时软连接的大小是被连接文件路径的字符长度。

## 文本处理和统计
### awk
```bash
# 读取账户信息，以":"作为分隔符进行分列（-F选项）(默认是任意空行)
# 并打印出第一列和第五列，中间用空格分隔
# 将输出删除其中1-10行。
cat -n /etc/passwd | gawk -F ':' '{print $1" "$5}' | gsed '1,10d'
```
### sed
现在一般都使用加强版的gsed，用来~~~~编辑文本
通常的模式是[n, m][command] 表示对n-m行做操作
假设我们有一个文本叫test.txt
```
1    2015-12-25    1.2366    1.2366
2    2015-12-24    1.2296    1.2296
3    2015-12-23    1.2324    1.2324
4    2015-12-22    1.2454    1.2454
5    2015-12-21    1.2351    1.2351
6    2015-12-18    1.2218    1.2218
7    2015-12-17    1.2247    1.2247
8    2015-12-16    1.1965    1.1965
9    2015-12-15    1.1906    1.1906
```
增：使用a命令
```bash
> gsed '4a 插入的第一行\n插入的第二行' test.txt
1    2015-12-25    1.2366    1.2366
2    2015-12-24    1.2296    1.2296
3    2015-12-23    1.2324    1.2324
4    2015-12-22    1.2454    1.2454
插入的第一行
插入的第二行
5    2015-12-21    1.2351    1.2351
6    2015-12-18    1.2218    1.2218
7    2015-12-17    1.2247    1.2247
8    2015-12-16    1.1965    1.1965
9    2015-12-15    1.1906    1.1906
```
删：使用d 命令
```bash
$ gsed '2,3d' test.txt
1    2015-12-25    1.2366    1.2366
4    2015-12-22    1.2454    1.2454
5    2015-12-21    1.2351    1.2351
6    2015-12-18    1.2218    1.2218
7    2015-12-17    1.2247    1.2247
8    2015-12-16    1.1965    1.1965
9    2015-12-15    1.1906    1.1906
```
改：使用c命令
```bash
$ gsed '4,6c 插入的第一行\n插入的第二行' test.txt
1    2015-12-25    1.2366    1.2366
2    2015-12-24    1.2296    1.2296
3    2015-12-23    1.2324    1.2324
插入的第一行
插入的第二行
7    2015-12-17    1.2247    1.2247
8    2015-12-16    1.1965    1.1965
9    2015-12-15    1.1906    1.1906
```
使修改对源文件生效，同时生成备份文件
```bash
> gsed -i.bak '4a haha\nxixi' test.txt
```
## 文件传输
- rsync
    将单个文件/符合正则的文件传送到远程，或者将远程文件传送到本地
    
    ```BASH
    # Transfer file from local to remote host:
    $ rsync path/to/local_file remote_host:path/to/remote_directory
    ```
    
    
## 进程状态查询
- 在上一个进程结束后，可以使用

```bash
$ echo $?
```
来查看进程退出信号，其中0是正常退出，非0是异常退出

## 文件收集和复制
```bash
 find ./ -iname "*.json" -type f -exec cp {} ./test/ \;
```